package io.akka.sample.ml

import akka.NotUsed
import akka.stream.scaladsl.Flow
import com.typesafe.config.Config
import hex.genmodel.GenModel
import io.akka.sample.model.{MachineStatus, NeedMoreData}

trait IoTDeepLearningDetection {

  def config: Config
  
  // Prediction configurations
  // Prediction window size, has to be the same as the window size used to model training
  private var window: Int = 200
  // How long are persisting predictions
  private var predictionCacheSize: Int = window * 5
  // How many failure predictions do we consider as an actual failure.
  private var failureRate: Double = 5.0 / predictionCacheSize.toDouble

  // Feature names
  private var headers = Array("LinAccX (g)", "LinAccY (g)", "LinAccZ (g)")
  // Number of features per observation
  private var features: Int = headers.length

  val fullWindowFeatures = features * window

  // model generated by H2O
  private val rawModel = Class.forName("iot_dl").newInstance().asInstanceOf[GenModel]

  private lazy val threshold: Double = config.getDouble("h2o.threshold")

  
  def score(features: Vector[Double], previousPredictions: SimpleRingBuffer[MachineStatus]): Either[NeedMoreData, MachineStatus] = {
    if (features.length == fullWindowFeatures) {
      val preds = Array.fill[Double](fullWindowFeatures)(0)
      val fs = features.toArray
      val pred = rawModel.score0(fs, preds)
      
      
      // Calculating the mean squared error of our prediction
      val rmse = meanSquaredError(fs, pred)

      // If our RMSE if big enough we classify it as a failure 1, otherwise 0
      val label = 
        if (rmse > threshold) MachineStatus.Misbehaving
        else MachineStatus.Ok

      previousPredictions += label

      // If failure rate % of predictions in our cache are failures - set the state to failed
        val aboveFailureRate = (previousPredictions.foldLeft(0)(_ + _.value).toDouble / previousPredictions.length.toDouble) >= failureRate
        
      Right(if (aboveFailureRate) MachineStatus.Misbehaving else MachineStatus.Ok)
    } else Left(NeedMoreData)
  }

  private def meanSquaredError(features: Array[Double], pred: Array[Double]) = {
    features.zip(pred).map { case (i, p) => (p - i) * (p - i) }.sum / fullWindowFeatures.toDouble
  }
  
  def scoringFlow: Flow[Double, MachineStatus, NotUsed] =
    Flow[Double].statefulMapConcat { () =>
      val previousPredictionsBuffer: SimpleRingBuffer[MachineStatus] = new SimpleRingBuffer(predictionCacheSize)
      var measurements: Vector[Double] = Vector.empty
      
      { measurement =>
        
        measurements = measurements :+ measurement
        
        score(measurements, previousPredictionsBuffer) match {
          case Left(NeedMoreData) => 
            Nil
            
          case Right(machineStatus) =>
            measurements = Vector.empty
            List(machineStatus)
        }
      }
    }
  
}
